import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { getAllQuestions, searchWebQuestions, createNewWebQuestion } from '../../api';
import { useNavigate } from 'react-router-dom';

        import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { getAllQuestions, searchWebQuestions, createNewWebQuestion } from '../../api';
import { useNavigate } from 'react-router-dom';
import './QuestionsPage.css';
import ProblemDetails from '../../components/ProblemDetail/problemDetail';
import QuestionsTable from '../../components/QuestionsTable';
import { debounce } from '../../utils/PrivateRoute';
import axios from 'axios';
        {duplicateMessage && (
          <div className="duplicate-message-container">
            <div className="duplicate-message">
              <h4>Question Already Exists</h4>
              <p>{duplicateMessage.message}</p>
              <div className="duplicate-actions">
                <button 
                  className="add-anyway-button"
                  onClick={() => handleInsertToDb(duplicateMessage.webResult, true)}
                >
                  Add Anyway
                </button>
                <button 
                  className="cancel-button"
                  onClick={() => setDuplicateMessage(null)}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Web Results Section */}
        {isAddingMode && webResults.length > 0 && (
          <div className="web-results-container">
            <h3 className="web-results-title">Web Results</h3>
            <div className="web-results-list">dom';
import './QuestionsPage.css';
import ProblemDetails from '../../components/ProblemDetail/problemDetail'; // Adjust the import path as necessary 
import QuestionsTable from '../../components/QuestionsTable';
import { debounce } from '../../utils/PrivateRoute';
import axios from 'axios';

const QuestionsPage = () => {
  const [questions, setQuestions] = useState([]);
  const [webResults, setWebResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isAddingMode, setIsAddingMode] = useState(false);
  const [webSearchTerm, setWebSearchTerm] = useState("");
  const [duplicateMessage, setDuplicateMessage] = useState(null);
  const [selectedSolution, setSelectedSolution] = useState(null);
  const [selectedProblem, setSelectedProblem] = useState(null);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [totalQuestions, setTotalQuestions] = useState(1);
  const [limit, setLimit] = useState(10);
  const [offset, setOffset] = useState(0);
  const [searchTerm, setSearchTerm] = useState("");
  const [difficulty, setDifficulty] = useState('');
  const [category, setCategory] = useState('');
  const navigate = useNavigate();

  const getQuestions = React.useCallback(async (limit_, offset_, search = "", difficulty_ = "", category_="") => {
    try {
      setIsLoading(true);
      const response = await getAllQuestions(limit_, offset_, search, difficulty_, category_);
      setQuestions(response.data.paginatedData);
      setTotalPages(Math.ceil(response.data.totalCount / limit_));
      setTotalQuestions(response.data.totalCount);
    } catch (error) {
      console.error('Error fetching questions:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const searchWebQuestions_ = async (searchTerm) => {
    if (!searchTerm.trim()) return;
    try {
      setIsLoading(true);
      // TODO: Replace with your actual web search API endpoint
      const response = await searchWebQuestions(searchTerm);
      const data =  response?.data || [];
      console.log("response", data)
      // const data = await response.json();
      
      setWebResults(data?.results || []);
    } catch (error) {
      console.error('Error searching web questions:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const debounceFunc = React.useMemo(() => debounce(getQuestions, 700), [getQuestions]);

  React.useEffect(() => {
    debounceFunc(limit, offset, searchTerm, difficulty, category);
  }, [limit, offset, searchTerm, difficulty, category, debounceFunc]);

  const handleQuestionClick = (id) => {
    navigate(`/coding-editor/${id}`);
  };

  const handlePageChange = (page) => {
    setCurrentPage(page);
    getQuestions(limit, page  * limit, searchTerm);
    setOffset(page  * limit);
  };
 

  const handleLimitChange = (event) => {
    setLimit(Number(event.target.value));
    getQuestions(Number(event.target.value), offset, searchTerm);
    setCurrentPage(1);
  };
  
 
  const handleViewSolution = (solution) => {
    setSelectedSolution(solution);
    setSelectedProblem(null); // Clear the problem description
  };

  const handleViewProblem = (question) => {
    setSelectedSolution(null); // Clear the solution view
    setSelectedProblem({...question}); // Set the problem description, sample input, and sample output
  };

  const handleDifficultyChange = (event) => {
    setDifficulty(event.target.value);
    setCurrentPage(1);
    // getQuestions(limit, 0, searchTerm, event.target.value, category);
    setOffset(0);
  };

  const handleCategoryChange =(event) => {
    setCategory(event.target.value);
    setCurrentPage(1);
    // getQuestions(limit, 0, searchTerm, event.target.value, category);
    setOffset(0);
  };

  const handleInsertToDb = async (webResult, forceDuplicate = false) => {
    try {
      setDuplicateMessage(null);
      const response = await createNewWebQuestion({ ...webResult, is_duplicate: forceDuplicate });
      
      if (response.data?.is_duplicate && !forceDuplicate) {
        setDuplicateMessage({
          message: response.data.message,
          result: response.data.result,
          webResult
        });
        return;
      }

      // If the question was successfully added
      setWebResults(prev => prev.filter(item => item.title !== webResult.title));
      await getQuestions(limit, offset, searchTerm, difficulty, category);
      setDuplicateMessage(null);
    } catch (error) {
      console.error('Error inserting question:', error);
    }
  };
  console.log("webResults",webResults)
  return (
    <div className="questions-page">
      <div className="questions-list">
        <div className="questions-list-header">
          <div className="questions-header-content">
            <div className="questions-list-title-group">
              <h2 className="questions-title">Coding Questions</h2>
              <span className="questions-range">
                Showing {offset + 1} - {Math.min(offset + limit, totalQuestions)} of {totalQuestions} 
                <button 
                  className={`add-question-toggle ${isAddingMode ? 'active' : ''}`}
                  onClick={() => setIsAddingMode(!isAddingMode)}
                >
                {isAddingMode ? '×' : '+'}
              </button>
              </span>
            </div>
            {/* <button 
              className={`add-question-toggle ${isAddingMode ? 'active' : ''}`}
              onClick={() => setIsAddingMode(!isAddingMode)}
            >
              {isAddingMode ? '× Cancel' : '+ Add Question'}
            </button> */}
          </div>
          
          {isAddingMode && (
            <div className="web-search-bar">
              <input
                type="text"
                placeholder="Search for new questions from the web..."
                value={webSearchTerm}
                onChange={e => setWebSearchTerm(e.target.value)}
                className="web-search-input"
              />
              <button 
                className="web-search-button"
                onClick={() => searchWebQuestions_(webSearchTerm)}
                disabled={!webSearchTerm.trim()}
              >
                Search Web
              </button>
            </div>
          )}
        </div>

        <div className="questions-filters">
          <div className="questions-search-bar beautify">
            <input
              type="text"
              placeholder="Search existing questions..."
              value={searchTerm}
              onChange={e => setSearchTerm(e.target.value)}
              className="questions-search"
            />
            <select value={difficulty} onChange={handleDifficultyChange} className="questions-difficulty-select">
              <option value="">All Difficulties</option>
              <option value="Easy">Easy</option>
              <option value="Medium">Medium</option>
              <option value="Hard">Hard</option>
            </select>
            <select value={category} onChange={handleCategoryChange} className="questions-difficulty-select">
              <option value="">All Categories</option>
              <option value="string">String</option>
              <option value="array">Array</option>
              <option value="linked_list">Linked List</option>
            </select>
          </div>
        </div>

        {/* Web Results Section */}
        {isAddingMode && webResults.length > 0 && (
          <div className="web-results-container">
            <h3 className="web-results-title">Web Results</h3>
            <div className="web-results-list">
              {webResults.map((result, id) => (
                <div key={id} className="web-result-item">
                  <div className="web-result-info">
                    <h4>{result.title}</h4>
                    <span 
                      className="web-result-difficulty"
                      data-difficulty={result.difficulty}
                    >
                      {result.difficulty}
                    </span>
                  </div>
                  <button
                    onClick={() => handleInsertToDb(result)}
                    className="insert-db-button"
                    title="Add this question to your database"
                  >
                    Add to Database
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {isLoading && (
          <div className="loading-indicator">
            Searching...
          </div>
        )}

        <QuestionsTable
          questions={questions}
          handleViewSolution={handleViewSolution}
          handleQuestionClick={handleQuestionClick}
          handleViewProblem={handleViewProblem}
        />

        <div className='pagination-container'>
          <select id="limit" value={limit} onChange={handleLimitChange} className="questions-limit-select">
            <option value={5}>5</option>
            <option value={10}>10</option>
            <option value={15}>15</option>
          </select>
          <div className="pagination-buttons">
            <button className={currentPage === 0 ? 'disabled' : ''} onClick={() => handlePageChange(currentPage - 1)}>{'<'}</button>
            <button className={(offset + limit) >= totalQuestions ? 'disabled' : ''} onClick={() => handlePageChange(currentPage + 1)}>{'>'}</button>
          </div>
        </div>
      </div>
       
      <div className="solution-container">
        {(!selectedProblem && !selectedSolution) && <h1>Details</h1>}
        <ProblemDetails selectedProblem={selectedProblem} selectedSolution={selectedSolution} />
      </div>
    </div>
  );
};

export default QuestionsPage;